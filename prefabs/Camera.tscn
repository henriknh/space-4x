[gd_scene load_steps=2 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Camera

# Store state of current key presses
var keys = {
	'left': false,
	'right': false,
	'up': false,
	'down': false,
}

# Store state of current touches
var touches = {}

# Right mouse button was or is pressed.
var is_drag = false

# Zoom limit
export (int) var zoom_in_limit = 1
export (int) var zoom_out_limit = 1


# Limit bounds of camera 
var bounds_limit = 0

# Camera speed in px/s.
export (int) var camera_speed = 450

# Value meaning how near to the window edge (in px) the mouse must be,
# to move a view.
export (int) var camera_margin = 20

# Zoom speed factor that is used with current zoom to calculate next zoom value
const camera_zoom_speed = 25

# Vector of camera's movement / second.
var camera_movement = Vector2()

# Previous mouse position used to count delta of the mouse movement.
var _prev_mouse_pos = null

signal zoom_changed

func _ready():
	
	zoom_out_limit += Consts.PLANET_SYSTEM_BASE_DISTANCE_TO_SUN
	zoom_out_limit += Consts.PLANET_SYSTEM_RADIUS 
	zoom_out_limit /= 200
	
	bounds_limit += Consts.PLANET_SYSTEM_BASE_DISTANCE_TO_SUN
	bounds_limit += Consts.PLANET_SYSTEM_RADIUS 
	bounds_limit += Consts.ASTEROIDS_EXTRA_DISTANCE
	
	GameState.connect(\"state_changed\", self, \"load_camera_state\")
	
	var timer = Timer.new()
	timer.connect(\"timeout\", self, \"set_camera_state\") 
	timer.wait_time = 1
	add_child(timer)
	timer.start()
	
func load_camera_state():
	var camera_state = GameState.get_camera_state()
	
	if camera_state.has('pos_x'):
#		position = Vector3(camera_state['pos_x'], camera_state['pos_y'])
#		last_pos = position
		pass
	
	if camera_state.has('zoom'):
#		zoom = Vector2(camera_state['zoom'], camera_state['zoom'])
#		last_zoom = zoom
#		emit_signal(\"zoom_changed\")
		pass

func set_camera_state() -> void:
#	if last_pos != position or last_zoom != zoom:
#		GameState.set_camera_setting({
#			\"pos_x\": self.position.x,
#			\"pos_y\": self.position.y,
#			\"zoom\": self.zoom.x
#		})
#		last_pos = position
#		last_zoom = zoom
	pass
	
	


var velocity: Vector2 = Vector2.ZERO
var velocity_by_input: Vector2 = Vector2.ZERO
export(float,1,100) var movement_speed = 30
export(float, 0.01, 0.99) var movement_damping = 0.74

var mouse_wheel: float = 0
const mouse_wheel_damping = 0.9
export(float, 10,100) var min_zoom = 10
export(float, 10,100) var max_zoom = 100
export(float, 1,3) var zoom_sensibility = 2.5

export(float,0.001,1.0) var screen_edge_size : float = 0.3

func _process(delta):
	
	if velocity_by_input != Vector2.ZERO:
		velocity = velocity_by_input
		
	if velocity != Vector2.ZERO:
		velocity.x = clamp(velocity.x * movement_damping,-1.0,1.0)
		velocity.y = clamp(velocity.y * movement_damping,-1.0,1.0)
		move(velocity)
		
	if mouse_wheel != 0:
		mouse_wheel = mouse_wheel * mouse_wheel_damping
		zoom(mouse_wheel)

func move(velocity: Vector2):
	#Move along cameras X axis
	global_transform.origin += global_transform.basis.x * velocity.x * movement_speed * get_process_delta_time()
	#Calculate a forward camera direction that is perpendicular to the XZ plane
	var forward = global_transform.basis.x.cross(Vector3.UP)
	#Move the camera along that forward direction
	global_transform.origin += forward * velocity.y * movement_speed * get_process_delta_time()

func zoom(direction : float):
	#Zooming using fov
	var new_fov = fov + (sign(direction) * pow(abs(direction),zoom_sensibility)/100 * get_process_delta_time())
	fov = clamp(new_fov, min_zoom, max_zoom)
	
func _input(event):
	if event is InputEventMouseMotion:
		var view_size = get_viewport().get_visible_rect().size - Vector2.ONE
		var delta = (event.position) / view_size
		delta = (delta * 2) - Vector2.ONE #[-1, 1]
		
		#Store it an buffer to use it on _process
		#Calculates delta based on percentage between the edge size and the actual edge
		var horizontal = max(abs(delta.x) - (1.0 - screen_edge_size),0)
		var vertical = max(abs(delta.y) - (1.0 - screen_edge_size),0)
		#Converts it to an [0.0,1.0] range
		horizontal = range_lerp(horizontal,0.0,screen_edge_size,0.0,1.0)
		vertical = range_lerp(vertical,0.0,screen_edge_size,0.0,1.0)
		#Applies direction
		horizontal *= sign(delta.x)
		vertical *= sign(delta.y)
		velocity_by_input = Vector2(horizontal, vertical)
"

[node name="Camera" type="Camera"]
script = SubResource( 1 )
